<!DOCTYPE html>
<html>
    <head>
	<link rel="icon" 
      href="images/favicon.ico">
	 <link href='http://fonts.googleapis.com/css?family=Libre+Baskerville' rel='stylesheet' type='text/css'>
        <meta charset="utf-8">
        <title>The Yiye Universe</title>
		
        <style>
            html, body {
                width: 100%;
                height: 100%;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

            }

            body {
                background-color: #ffffff;
                margin: 0;
                overflow: hidden;
                font-family:'Libre Baskerville', serif;
				font-size: 25px;
            }

            #blocker {

                position: absolute;

                width: 100%;
                height: 100%;

                background-color: rgba(0,0,0,0.5);

            }

            #instructions {

                width: 100%;
                height: 100%;

                display: -webkit-box;
                display: -moz-box;
                display: box;

                -webkit-box-orient: horizontal;
                -moz-box-orient: horizontal;
                box-orient: horizontal;

                -webkit-box-pack: center;
                -moz-box-pack: center;
                box-pack: center;

                -webkit-box-align: center;
                -moz-box-align: center;
                box-align: center;

                color: #ffffff;
                text-align: centre;

                cursor: pointer;

            }
			
			#txt {


                display: -webkit-box;
                display: -moz-box;
                display: box;

                -webkit-box-orient: horizontal;
                -moz-box-orient: horizontal;
                box-orient: horizontal;

                -webkit-box-pack: top;
                -moz-box-pack: top;
                box-pack: top;

                -webkit-box-align: centre;
                -moz-box-align: centre;
                box-align: centre;

                color: #ffffff;
                align: center;
background-color: rgba(0, 255, 255, 0.0);
                cursor: pointer;

            }
div#load_screen{
	background: #000;
	opacity: 1;
	position: fixed;
    z-index:10;
	top: 0px;
	width: 100%;
	height: 100%;
	cursor: wait;
}
div#load_screen > div#loading{
font-family: 'Libre Baskerville', serif;
  width: 50%;
  height: 50%;
  overflow: auto;
  margin: auto;
  position: absolute;
  top: 0; left: 0; bottom: 0; right: 0;
  color: #FFFFFF;
  cursor: wait;
}

        </style>
		
		<script>
function startTime() {
    var today=new Date();
    var h=today.getHours();
    var m=today.getMinutes();
    var s=today.getSeconds();
    m = checkTime(m);
    s = checkTime(s);
    document.getElementById('txt').innerHTML = h+":"+m+":"+s;
    var t = setTimeout(function(){startTime()},500);
}

function checkTime(i) {
    if (i<10) {i = "0" + i};  // add zero in front of numbers < 10
    return i;
}
</script>
<script>
var canshoot=false;
window.addEventListener("load", function(){
	var load_screen = document.getElementById("load_screen");
	document.body.removeChild(load_screen);
});
</script>
    </head>
	<div id="load_screen"><div id="loading"><CENTER><span style="font-size:80px">LOADING </span> <br> <span style="font-size:20px">This may take some time. </span></div></div>
    <body onload="startTime()">
				
        <script src="libs/Three.js"></script>
        <script src="build/cannon.js"></script>
        <script src="js/PointerLockControls.js"></script>
		<script src="js/stats.min.js"></script>
		<script src="js/Mirror.js"></script>
		<script src="js/WaterShader.js"></script>
		<script src="js/TerrainShaders.js"></script>
        <script src="js/TerrainMaterial.js"></script>
		<script src='js/threex.keyboardstate.js'></script>
		<script src='js/threex.daynight.js'></script>
		 
        <div id="blocker">

            <div id="instructions">
			<center>
			<div id="txt"></div>
			<br>
			<center>
			<img src="images/logolarge.png" width="100%" height="auto"><br>
                <span style="font-size:40px">CLICK TO PLAY</span>
                <br />
				Last Update: 19/04/2015
				<br />
                (W,A,S,D = Move, SPACE = Jump, MOUSE = Look, CLICK = Shoot) <br />
			<i>	Pre-ALPHA </i> <br />
			This game uses <a href="http://threejs.org/"> three.js </a> and <a href="http://cannonjs.org/"> cannon.js </a>
			<br />
			<br />
			<a href="javascript:history.go(0)"> <img src="images/reset.png"> </a>
			<br>
			

        </div>
        <script>
	
            var sphereShape, sphereBody, world, physicsMaterial, walls=[], balls=[], ballMeshes=[], boxes=[], boxMeshes=[];
var keyboard    = new THREEx.KeyboardState();
            var camera, scene, renderer;
            var geometry, material, mesh;
            var controls,time = Date.now();

            var blocker = document.getElementById( 'blocker' );
            var instructions = document.getElementById( 'instructions' );
			
			var stats = new Stats();
stats.setMode(0); // 0: fps, 1: ms
// align top-left
stats.domElement.style.position = 'absolute';
stats.domElement.style.left = '0px';
stats.domElement.style.top = '0px';

document.body.appendChild( stats.domElement );

            var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

            if ( havePointerLock ) {

                var element = document.body;

                var pointerlockchange = function ( event ) {

                    if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {

                        controls.enabled = true;

                        blocker.style.display = 'none';

                    } else {

                        controls.enabled = false;

                        blocker.style.display = '-webkit-box';
                        blocker.style.display = '-moz-box';
                        blocker.style.display = 'box';

                        instructions.style.display = '';

                    }

                }

                var pointerlockerror = function ( event ) {
                    instructions.style.display = '';
                }

                // Hook pointer lock state change events
                document.addEventListener( 'pointerlockchange', pointerlockchange, false );
                document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
                document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

                document.addEventListener( 'pointerlockerror', pointerlockerror, false );
                document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
                document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

                instructions.addEventListener( 'click', function ( event ) {
                    instructions.style.display = 'none';

                    // Ask the browser to lock the pointer
                    element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;

                    if ( /Firefox/i.test( navigator.userAgent ) ) {

                        var fullscreenchange = function ( event ) {

                            if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {

                                document.removeEventListener( 'fullscreenchange', fullscreenchange );
                                document.removeEventListener( 'mozfullscreenchange', fullscreenchange );

                                element.requestPointerLock();
                            }

                        }

                        document.addEventListener( 'fullscreenchange', fullscreenchange, false );
                        document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );

                        element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;

                        element.requestFullscreen();

                    } else {

                        element.requestPointerLock();

                    }

                }, false );

            } else {

                instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';

            }

			
            initCannon();
            init();
            animate();

            function initCannon(){
                // Setup our world
                world = new CANNON.World();
                world.quatNormalizeSkip = 0;
                world.quatNormalizeFast = false;

                var solver = new CANNON.GSSolver();

                world.defaultContactMaterial.contactEquationStiffness = 1e9;
                world.defaultContactMaterial.contactEquationRegularizationTime = 60;

                solver.iterations = 50;
                solver.tolerance = 0.01;
                var split = true;
                if(split)
                    world.solver = new CANNON.SplitSolver(solver);
                else
                    world.solver = solver;

                world.gravity.set(0,-30,0);
                world.broadphase = new CANNON.NaiveBroadphase();

                // Create a slippery material (friction coefficient = 0.0)
                physicsMaterial = new CANNON.Material("slipperyMaterial");
                var physicsContactMaterial = new CANNON.ContactMaterial(physicsMaterial,
                                                                        physicsMaterial,
                                                                        0.0, // friction coefficient
                                                                        0.03  // restitution
                                                                        );
                // We must add the contact materials to the world
                world.addContactMaterial(physicsContactMaterial);

                // Create a sphere THIS IS THE PLAYER
                var mass = 7, radius = 0.9;
				//var mass = 5, radius = 1.3;
                sphereShape = new CANNON.Sphere(radius);
                sphereBody = new CANNON.Body({ mass: mass });
                sphereBody.addShape(sphereShape);
                //CITY//sphereBody.position.set(0,66,141);
				//TREE //sphereBody.position.set(0,195,-40008);

				sphereBody.position.set(22,147,2236);
				
				//position player in tree
				//sphereBody.position.set(0,195,-40008);
                //Actual Sphere Speed
				sphereBody.linearDamping = 0.999;
				
				//Debug speed
						//sphereBody.linearDamping = 0.2;
                world.add(sphereBody);
				
			

   /*             // Create a plane
                var groundShape = new CANNON.Plane(10,30,10);
                var groundBody = new CANNON.Body({ mass: 0 });
                groundBody.addShape(groundShape);
                groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
                world.add(groundBody);*/
            }

            function init() {

                camera = new THREE.PerspectiveCamera( 90, window.innerWidth / window.innerHeight, 0.1, 50000 );
									var loader = new THREE.ObjectLoader();	
/*loader.load("models/basemesh.json", 
    function ( obj ) {
	obj.material.emmissive = 0xcccccc;
	obj.material.shininess = 0.4;
	obj.material.shading = THREE.SmoothShading;
       camera.add( obj );
	  obj.geometry.mergeVertices();
		obj.geometry.computeVertexNormals();
	   //obj.scale.set(2.145,2,2.145,2.145);
	   obj.rotation.y = - 180 * ( Math.PI / 180 );
	   obj.scale.set( 0.08, 0.08, 0.08 );
	   obj.position.set(0,-1,-0.8);
	 obj.castShadow = true;
	 obj.receiveShadow = true;
    }   
);*/
				var reticleMaterial = new THREE.SpriteMaterial( 
					{ 
						map: new THREE.ImageUtils.loadTexture( 'images/reticle.gif' ), 
						//useScreenCoordinates: false, alignment: THREE.SpriteAlignment.center,
						color: 0xffffff, transparent: false, blending: THREE.AdditiveBlending
					});
					var reticle = new THREE.Sprite( reticleMaterial );
					reticle.scale.set(0.01, 0.01, 0.01);	
					reticle.position.set( -0, 0, -0.11 );
					//camera.add(reticle);	
					
				//sphereBody.position.set(0,66,0);
				var camlight = new THREE.PointLight(0xFFFFFF, 0.5, 1 );
					camera.add(camlight);

                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2( 0xbbbbff, 0.001 );

                var ambient = new THREE.AmbientLight( 0x222222 );
                scene.add( ambient );
				var collisionmat=new THREE.MeshBasicMaterial({transparent: true, opacity: 0});
				
               light = new THREE.DirectionalLight( 0xFFFFF2,1.5 );
                light.position.set( -100, 2000, 2000 );
                light.target.position.set( 0, 0, 0 );
                if(true){
                    light.castShadow = true;

                    light.shadowCameraNear = 2;
                    light.shadowCameraFar = 1000;//camera.far;
                    light.shadowCameraFov = 90;

                    light.shadowMapBias = 0.5;
                    light.shadowMapDarkness = 0.7;
                    light.shadowMapWidth = 8*512;
                    light.shadowMapHeight = 8*512;

                    light.shadowCameraVisible = true;
                }
                scene.add( light );
				
				var cloudtex = new THREE.ImageUtils.loadTexture( 'tex/cloudlayer.png' );
						//cloudtex.wrapS = cloudtex.wrapT = THREE.RepeatWrapping; 
	//cloudtex.repeat.set( 3, 3 );
				//var cloudgeometry = new THREE.SphereGeometry( 4500, 6, 6 );
				var cloudgeometry = new THREE.SphereGeometry( 10000, 6, 6 );
var cloudmaterial = new THREE.MeshBasicMaterial( {side: THREE.BackSide, map: cloudtex, transparent: true,fog: false,  color: 0xffdede, emissive: 0xffffff } );
var cloudsphere = new THREE.Mesh( cloudgeometry, cloudmaterial );
scene.add( cloudsphere );
cloudsphere.position.set(0,0,2000);
//cloudsphere.rotation.x = 90  * ( Math.PI / 180 );
 
/* light2 = new THREE.SpotLight( 0xFFFFF2,1.5 );
                light2.position.set( 100, 300, 200 );
                light2.target.position.set( 0, 0, 0 );
					scene.add(light2);

*/
                controls = new PointerLockControls( camera , sphereBody );
                scene.add( controls.getObject() );

                // floor
                geometry = new THREE.PlaneGeometry( 10, 30, 50, 50 );
                geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

                material = new THREE.MeshPhongMaterial( { color: 0xdddddd} );
				spellmaterial = new THREE.MeshBasicMaterial( { color:0xffffff } );

                mesh = new THREE.Mesh( geometry, material );
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add( mesh );
				
				//Cylinder for menu
var menugeometry = new THREE.CylinderGeometry( 0.5, 0.5, 10, 16 );
var menumaterial = new THREE.MeshBasicMaterial( {color: 0x000000, side: THREE.BackSide} );
var menucylinder = new THREE.Mesh( menugeometry, menumaterial );
scene.add( menucylinder );

				//Rendering and all that jazz
                renderer = new THREE.WebGLRenderer({antialias:false});
				//renderer.sortObjects = true;
                renderer.shadowMapEnabled = false;
                renderer.shadowMapSoft = false;
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.setClearColor( scene.fog.color, 1 );

                document.body.appendChild( renderer.domElement );

                window.addEventListener( 'resize', onWindowResize, false );

              //TEST AREA NOTIFICATION
			  /*
			  var testgeometry = new THREE.PlaneGeometry( 20, 20, 1 );
var testmaterial = new THREE.MeshBasicMaterial( {map: THREE.ImageUtils.loadTexture( 'tex/testarea.gif' ), transparent:true, side: THREE.DoubleSide} );
var testplane = new THREE.Mesh( testgeometry, testmaterial );
scene.add( testplane );
testplane.position.set(0,20,0);
testplane.rotation.x = -90 * Math.PI / 180;
*/

/*
			  // Add boxes
                var halfExtents = new CANNON.Vec3(1,1,1);
                var boxShape = new CANNON.Box(halfExtents);
                var boxGeometry = new THREE.BoxGeometry(halfExtents.x*2,halfExtents.y*2,halfExtents.z*2);
                for(var i=0; i<7; i++){
                    var x = (Math.random()-0.5)*20;
                    var y = 1 + (Math.random()-0.5)*1;
                    var z = (Math.random()-0.5)*20;
                    var boxBody = new CANNON.Body({ mass: 5 });
                    boxBody.addShape(boxShape);
                    var boxMesh = new THREE.Mesh( boxGeometry, material );
                    world.add(boxBody);
                    scene.add(boxMesh);
                    boxBody.position.set(x,y,z);
                    boxMesh.position.set(x,y,z);
                    boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    boxes.push(boxBody);
                    boxMeshes.push(boxMesh);
                }
*/
//First Zone Start Tree Interior Dark
var blankmaterial = new THREE.MeshBasicMaterial({color:0x000000});
 var halfExtents = new CANNON.Vec3(40,0.002,40);
                var boxShape = new CANNON.Box(halfExtents);
                var boxGeometry = new THREE.BoxGeometry(halfExtents.x*2,halfExtents.y*2,halfExtents.z*2);
				var x = 0;
                    var y = 194;
                    var z = -40039;
				//var boxBody = new CANNON.Body({ mass: 0 });
				var boxBody = new CANNON.Body({ mass: 0 });
                    boxBody.addShape(boxShape);
                    var boxMesh = new THREE.Mesh( boxGeometry, blankmaterial );
                    world.add(boxBody);
                    scene.add(boxMesh);
                    boxBody.position.set(x,y,z);
                    boxMesh.position.set(x,y,z);
                    boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    boxes.push(boxBody);
                    boxMeshes.push(boxMesh);
					var halfExtents = new CANNON.Vec3(40,0.002,40);
                var boxShape = new CANNON.Box(halfExtents);
                var boxGeometry = new THREE.BoxGeometry(halfExtents.x*2,halfExtents.y*2,halfExtents.z*2);
				var x = 0;
                    var y = 234;
                    var z = -40039;
				//var boxBody = new CANNON.Body({ mass: 0 });
				var boxBody = new CANNON.Body({ mass: 0 });
                    boxBody.addShape(boxShape);
                    var boxMesh = new THREE.Mesh( boxGeometry, blankmaterial );
                    world.add(boxBody);
                    scene.add(boxMesh);
                    boxBody.position.set(x,y,z);
                    boxMesh.position.set(x,y,z);
                    boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    boxes.push(boxBody);
                    boxMeshes.push(boxMesh);
 var halfExtents = new CANNON.Vec3(0.002,40,40);
                var boxShape = new CANNON.Box(halfExtents);
                var boxGeometry = new THREE.BoxGeometry(halfExtents.x*2,halfExtents.y*2,halfExtents.z*2);
				var x = 40;
                    var y = 194;
                    var z = -40039;
				//var boxBody = new CANNON.Body({ mass: 0 });
				var boxBody = new CANNON.Body({ mass: 0 });
                    boxBody.addShape(boxShape);
                    var boxMesh = new THREE.Mesh( boxGeometry, blankmaterial );
                    world.add(boxBody);
                    scene.add(boxMesh);
                    boxBody.position.set(x,y,z);
                    boxMesh.position.set(x,y,z);
                    boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    boxes.push(boxBody);
                    boxMeshes.push(boxMesh);
					 var halfExtents = new CANNON.Vec3(0.002,40,40);
                var boxShape = new CANNON.Box(halfExtents);
                var boxGeometry = new THREE.BoxGeometry(halfExtents.x*2,halfExtents.y*2,halfExtents.z*2);
				var x = -40;
                    var y = 194;
                    var z = -40039;
				//var boxBody = new CANNON.Body({ mass: 0 });
				var boxBody = new CANNON.Body({ mass: 0 });
                    boxBody.addShape(boxShape);
                    var boxMesh = new THREE.Mesh( boxGeometry, blankmaterial );
                    world.add(boxBody);
                    scene.add(boxMesh);
                    boxBody.position.set(x,y,z);
                    boxMesh.position.set(x,y,z);
                    boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    boxes.push(boxBody);
                    boxMeshes.push(boxMesh);
					 var halfExtents = new CANNON.Vec3(40,40,0.002);
                var boxShape = new CANNON.Box(halfExtents);
                var boxGeometry = new THREE.BoxGeometry(halfExtents.x*2,halfExtents.y*2,halfExtents.z*2);
				var x = 0;
                    var y = 194;
                    var z = -39999;
				//var boxBody = new CANNON.Body({ mass: 0 });
				var boxBody = new CANNON.Body({ mass: 0 });
                    boxBody.addShape(boxShape);
                    var boxMesh = new THREE.Mesh( boxGeometry, blankmaterial );
                    world.add(boxBody);
                    scene.add(boxMesh);
                    boxBody.position.set(x,y,z);
                    boxMesh.position.set(x,y,z);
                    boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    boxes.push(boxBody);
                    boxMeshes.push(boxMesh);
					 var halfExtents = new CANNON.Vec3(40,40,0.002);
                var boxShape = new CANNON.Box(halfExtents);
                var boxGeometry = new THREE.BoxGeometry(halfExtents.x*2,halfExtents.y*2,halfExtents.z*2);
				var x = 0;
                    var y = 194;
                    var z = -40039;
				//var boxBody = new CANNON.Body({ mass: 0 });
				var boxBody = new CANNON.Body({ mass: 0 });
                    boxBody.addShape(boxShape);
                    var boxMesh = new THREE.Mesh( boxGeometry, blankmaterial );
                    world.add(boxBody);
                    scene.add(boxMesh);
                    boxBody.position.set(x,y,z);
                    boxMesh.position.set(x,y,z);
                    boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    boxes.push(boxBody);
                    boxMeshes.push(boxMesh);
					var doormaterial = new THREE.MeshBasicMaterial({map:new THREE.ImageUtils.loadTexture("tex/doortree.png"), transparent: true});
					//var doorgeometry = new THREE.PlaneGeometry( 1, 1, 1 );
					//var doorplane = new THREE.Mesh( doorgeometry, doormaterial );
					var halfExtents = new CANNON.Vec3(1,1,0.5);
                var boxShape = new CANNON.Box(halfExtents);
                var boxGeometry = new THREE.BoxGeometry(halfExtents.x*2,halfExtents.y*2,0.00001);
					var x = 0;
                    var y = 195;
                    var z = -40038.9;
				//var boxBody = new CANNON.Body({ mass: 0 });
				var doorBody = new CANNON.Body({ mass: 0 });
                    doorBody.addShape(boxShape);
                    var boxMesh = new THREE.Mesh( boxGeometry, doormaterial );
                    world.add(doorBody);
                    scene.add(boxMesh);
                    doorBody.position.set(x,y,z);
                    boxMesh.position.set(x,y,z);
                    boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    boxes.push(doorBody);
                    boxMeshes.push(boxMesh);
							  doorBody.addEventListener("collide",function(e){
  var canshoot=true;   
  //player position through door
 //sphereBody.position.set(84,214.5,3770);
 sphereBody.position.set(32,821.5,5239); 
//sphereBody.position.set(1200,395,3770);	
          });
//scene.add( doorplane );
//doorplane.position.set(0,200,-4038.78);
var loader = new THREE.ObjectLoader();	
loader.load("models/rockarch.js", 
    function ( obj ) {
	obj.material.emmissive = 0xcccccc;
	obj.material.shininess = 0.4;
	obj.material.shading = THREE.SmoothShading;
       scene.add( obj );
	  obj.geometry.mergeVertices();
		obj.geometry.computeVertexNormals();
	   //obj.scale.set(2.145,2,2.145,2.145);
	   obj.rotation.y = - 90 * ( Math.PI / 180 );
	   obj.scale.set( 5, 5, 5 );
	   obj.position.set(12,146,1446);
	 obj.castShadow = true;
	 obj.receiveShadow = true;
    }   
);

mainterrain();
function mainterrain(){
//TERRAIN HFSHAPE
//return array with height data from img
                var splat1 = THREE.ImageUtils.loadTexture("tex/grasstex2.jpg");
                var splat2 = THREE.ImageUtils.loadTexture("tex/grasstex2.jpg");
                var splat3 = THREE.ImageUtils.loadTexture("tex/grasstex2.jpg");
                var splat4 = THREE.ImageUtils.loadTexture("tex/rock.jpg");

                //TextureMap
				var alphaMap = THREE.ImageUtils.loadTexture("tex/splat2.png");
				//var alphaMap = THREE.ImageUtils.loadTexture("textures/terrain/splat2 - Copy.png");

                terrainUniforms.tAlphaMap.value = alphaMap;
                terrainUniforms.tSplat1.value = splat1;
                terrainUniforms.tSplat2.value = splat2;
                terrainUniforms.tSplat3.value = splat3;
                terrainUniforms.tSplat4.value = splat4;

                var terrainMaterial = new THREE.TerrainMaterial( {
                    uniforms: terrainUniforms,
                    vertexShader: terrainVertexShader,
                    fragmentShader:terrainFragShader,
					shading:THREE.SmoothShading,
					//bumpMap: terrainFragShader,
					//bumpScale:100,
                    lights: true,
                    fog: true
                });
				
function getHeightData(img,scale) {
  
 if (scale == undefined) scale=1;
  
    var canvas = document.createElement( 'canvas' );
    canvas.width = img.width;
    canvas.height = img.height;
    var context = canvas.getContext( '2d' );
 
    var size = img.width * img.height;
    var data = new Float32Array( size );
 
    context.drawImage(img,0,0);
 
    for ( var i = 0; i < size; i ++ ) {
        data[i] = 0
    }
 
    var imgd = context.getImageData(0, 0, img.width, img.height);
    var pix = imgd.data;
 
    var j=0;
    for (var i = 0; i<pix.length; i +=4) {
        var all = pix[i]+pix[i+1]+pix[i+2];
        data[j++] = all/(12*scale);
    }
     
    return data;
}
var img = new Image();
img.onload = function () {
  
    //get height data from img
    var data = getHeightData(img, scale);
 var grasstex = new THREE.ImageUtils.loadTexture( 'tex/grass2.jpg' );
	grasstex.wrapS = grasstex.wrapT = THREE.RepeatWrapping; 
	grasstex.repeat.set( 20480, 20480 ); 
	var rocklayertex = new THREE.ImageUtils.loadTexture( 'tex/rockbase.jpg' );
	rocklayertex.wrapS = rocklayertex.wrapT = THREE.RepeatWrapping; 
	rocklayertex.repeat.set( 10240, 10240 ); 
	var terrmat = new THREE.MeshPhongMaterial({map:grasstex});
    // plane
	//var geometry = new THREE.PlaneGeometry(2560,2560,63,63);
    var geometry = new THREE.PlaneGeometry(10240,10240,95,95);
    var texture = THREE.ImageUtils.loadTexture( 'tex/heightfield2.png' );
    var material = new THREE.MeshPhongMaterial( {  map:grasstex, wireframe: false, bumpMap: grasstex, bumpScale: 0.00, shininess:0.1, transparent: true} );
	var materialrock = new THREE.MeshPhongMaterial( {  map:rocklayertex, wireframe: false, bumpMap: rocklayertex, bumpScale: 0.20, shininess:0.1 } );
	//var material2 = new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true } );
	var material2 = new THREE.MeshBasicMaterial( { opacity: 0, transparent: true} );
    plane = new THREE.Mesh( geometry, terrainMaterial);

    //set height of vertices
    for ( var i = 0; i<plane.geometry.vertices.length; i++ ) {
         plane.geometry.vertices[i].z = data[i]*12;
    }
 
    scene.add(plane);
	plane.castShadow=true;
	plane.receiveShadow=true;
   plane.position.set(0,-1,5120);
   
   //plane.rotation.x = - 90 * ( Math.PI / 180 );
   var rot = new THREE.Vector3(-1,0,0)
		plane.quaternion.setFromAxisAngle(rot,(Math.PI/2));
		/*var rocklayer = new THREE.Mesh(plane.geometry, materialrock);
		scene.add(rocklayer);
		rocklayer.position.set(0,-1.001,2560);
		rocklayer.quaternion.setFromAxisAngle(rot,(Math.PI/2));*/

  /* 
           var vertices = [
plane.geometry.vertices.length
        ];
        var indices = [
            plane.geometry.indices
        ];
		*/
		  var verts=[], faces=[];
        var scale = 1;
        var rawVerts = plane.geometry.vertices;
        var rawFaces = plane.geometry.faces;
        // Get vertices
        for(var j=0; j<rawVerts.length; j+=1){
          verts.push(rawVerts[j].x * scale, rawVerts[j].y * scale, rawVerts[j].z * scale);
        }

        // Get faces

        for(var j=0; j<rawFaces.length; j+=1){
          faces.push(rawFaces[j].a,rawFaces[j].b,rawFaces[j].c);
        }

        //console.log({verts:verts, faces:faces});
//var shape2 = CANNON.Trimesh.createTorus(4, 3.5, 16, 16);
        var shape = new CANNON.Trimesh(verts,faces);
        //var trimeshShape = new CANNON.Trimesh(vertices, indices);
		var trimeshBody = new CANNON.Body({ mass: 0 });
		trimeshBody.addShape(shape);
		world.add(trimeshBody);
		trimeshBody.position.set(0, -1, 5120);
		var rot = new CANNON.Vec3(-1,0,0)
		trimeshBody.quaternion.setFromAxisAngle(rot,(Math.PI/2));
		
		//Render the fecker
		var testgeom = new THREE.Geometry();

            var v0 = new CANNON.Vec3();
            var v1 = new CANNON.Vec3();
            var v2 = new CANNON.Vec3();
            for (var i = 0; i < shape.indices.length / 3; i++) {
                shape.getTriangleVertices(i, v0, v1, v2);
                testgeom.vertices.push(
                    new THREE.Vector3(v0.x, v0.y, v0.z),
                    new THREE.Vector3(v1.x, v1.y, v1.z),
                    new THREE.Vector3(v2.x, v2.y, v2.z)
                );
                var j = testgeom.vertices.length - 3;
                testgeom.faces.push(new THREE.Face3(j, j+1, j+2));
            }
            testgeom.computeBoundingSphere();
            testgeom.computeFaceNormals();
            testmesh = new THREE.Mesh(testgeom, material2);
			scene.add(testmesh);
			var rot = new CANNON.Vec3(-1,0,0)
		testmesh.quaternion.setFromAxisAngle(rot,(Math.PI/2));
		testmesh.position.set(0,-1,5120);
};
// load img source
img.src = "tex/heightfield2.png";

}


 var pinetex = new THREE.ImageUtils.loadTexture( 'tex/bark2.jpg' );
	pinetex.wrapS = pinetex.wrapT = THREE.RepeatWrapping; 
	pinetex.repeat.set( 10, 10 );    
					var loader = new THREE.ObjectLoader();	
loader.load("models/treenew.json", 
    function ( obj ) {
	obj.material.map = pinetex;
	//obj.material.emmissive = 0xcccccc;
	obj.material.shininess = 0.4;
	obj.material.shading = THREE.SmoothShading;
       scene.add( obj );
	  obj.geometry.mergeVertices();
		obj.geometry.computeVertexNormals();
	   //obj.scale.set(2.145,2,2.145,2.145);
	   obj.scale.set( 0.6, 0.6, 0.6 );
	   obj.position.set(36,220,5230);
	 obj.castShadow = true;
	 obj.receiveShadow = true;
    }   
);
 var treetoptex = new THREE.ImageUtils.loadTexture( 'tex/treetex.png' );
loader.load("models/treetoptest.json", 
    function ( obj ) {
	obj.material.map = treetoptex;
	//obj.material.emmissive = 0xcccccc;
	obj.material.shininess = 0.4;
	obj.material.shading = THREE.SmoothShading;
       scene.add( obj );
	  obj.geometry.mergeVertices();
		obj.geometry.computeVertexNormals();
	   //obj.scale.set(2.145,2,2.145,2.145);
	   obj.scale.set( 0.6, 0.6, 0.6 );
	   obj.position.set(36,220,5230);
	 obj.castShadow = true;
	 obj.receiveShadow = true;
    }   
);
addcity();
addlandscape();

function addcity(){
//Gate Into City
 var gatetex = new THREE.ImageUtils.loadTexture( 'tex/pub.jpg' );
					var loader = new THREE.ObjectLoader();	
loader.load("models/pub.json", 
    function ( obj ) {
	obj.material.map = gatetex;
obj.material.emmissive = 0x111111;
	obj.material.shading = THREE.SmoothShading;

       scene.add( obj );
	   //obj.scale.set(2.145,2,2.145,2.145);
	   obj.scale.set( 1, 1, 1 );
	   obj.position.set(-6,35,-18);
	 obj.castShadow = true;
	 obj.receiveShadow = true;
	 obj.rotation.y = -90  * ( Math.PI / 180 );
    }   
);
 //City Floor BOX
 var floorTexture = new THREE.ImageUtils.loadTexture( 'tex/street2.jpg' );
	floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
	floorTexture.repeat.set( 512, 512 );
var patramaterial = new THREE.MeshPhongMaterial({
        map: floorTexture,
      });
 var halfExtents = new CANNON.Vec3(256,0.002,256);
                var boxShape = new CANNON.Box(halfExtents);
                var boxGeometry = new THREE.BoxGeometry(halfExtents.x*2,halfExtents.y*2,halfExtents.z*2);
				var x = 0;
                    var y = 65;
                    var z = -256;
				//var boxBody = new CANNON.Body({ mass: 0 });
				var boxBody = new CANNON.Body({ mass: 0 });
                    boxBody.addShape(boxShape);
                    var boxMesh = new THREE.Mesh( boxGeometry, patramaterial );
                    world.add(boxBody);
                    scene.add(boxMesh);
                    boxBody.position.set(x,y,z);
                    boxMesh.position.set(x,y,z);
                    boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    boxes.push(boxBody);
                    boxMeshes.push(boxMesh);
	 var citywallTexture = new THREE.ImageUtils.loadTexture( 'tex/brick.jpg' );
	citywallTexture.wrapS = citywallTexture.wrapT = THREE.RepeatWrapping; 
	citywallTexture.repeat.set( 51.2, 13.0 );
	var wallmaterial = new THREE.MeshPhongMaterial({
        map: citywallTexture,
      });
 var halfExtents = new CANNON.Vec3(256,65,256);
                var boxShape = new CANNON.Box(halfExtents);
                var boxGeometry = new THREE.BoxGeometry(halfExtents.x*2,halfExtents.y*2,halfExtents.z*2);
				var x = 0;
                    var y = 0;
                    var z = -256;
				//var boxBody = new CANNON.Body({ mass: 0 });
				var boxBody = new CANNON.Body({ mass: 0 });
                    boxBody.addShape(boxShape);
                    var boxMesh = new THREE.Mesh( boxGeometry, wallmaterial );
                    world.add(boxBody);
                    scene.add(boxMesh);
                    boxBody.position.set(x,y,z);
                    boxMesh.position.set(x,y,z);
                    boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    boxes.push(boxBody);
                    boxMeshes.push(boxMesh);

cityobjects();
function cityobjects(){

buildlibrary();

function buildlibrary(){
var base = new THREE.ImageUtils.loadTexture("tex/rock.jpg")     
base.wrapS	= THREE.RepeatWrapping;
	base.wrapT	= THREE.RepeatWrapping;
	base.repeat.x= 20
	base.repeat.y= 20
					var loader = new THREE.ObjectLoader();	
loader.load("models/librarybaserock.json", 
    function ( obj ) {
	obj.material.map = base;
	obj.material.bumpMap = base;
	obj.material.bumpScale = 0.25;
	//obj.material.emmissive = 0xcccccc;
	obj.material.shininess = 0.4;
	obj.material.shading = THREE.SmoothShading;
       scene.add( obj );
	   obj.geometry.mergeVertices();
		obj.geometry.computeVertexNormals();
	   //obj.scale.set(2.145,2,2.145,2.145);
	   var basescale = 2.68125;
	   obj.scale.set( 2.68125, 2.68125, 2.68125 );
	   obj.position.set(0,65,-550);
	 obj.castShadow = true;
	 obj.receiveShadow = true;
    }   
);
var libTexture = new THREE.ImageUtils.loadTexture( 'tex/libbricknice.jpg' );
	libTexture.wrapS = libTexture.wrapT = THREE.RepeatWrapping; 
	libTexture.repeat.set( 10000, 20000 );
	 var libbumpTexture = new THREE.ImageUtils.loadTexture( 'tex/libbricknice.jpg' );
	libbumpTexture.wrapS = libbumpTexture.wrapT = THREE.RepeatWrapping; 
	libbumpTexture.repeat.set( 10000, 20000);
	 	
var libext = new THREE.ImageUtils.loadTexture("tex/libbrick.jpg")     
libext.wrapS	= THREE.RepeatWrapping;
	libext.wrapT	= THREE.RepeatWrapping;
	libext.repeat.x= 40
	libext.repeat.y= 700
var libextmaterial = new THREE.MeshPhongMaterial({
        map: libTexture,
		bumpMap: libbumpTexture,
		bumpScale: 0.00,
      });	
	  //was 24
var loader = new THREE.ObjectLoader();	
loader.load("models/libraryext.json", 
    function ( obj ) {
	obj.material.map = libext;
	obj.material.bumpMap = libext;
	obj.material.bumpScale = 0.00;
	//obj.material.emmissive = 0xcccccc;
	obj.material.shininess = 1.4;
	obj.material.shading = THREE.SmoothShading;
	obj.material.side = THREE.FrontSide;
       scene.add( obj );
	   obj.rotation.y = -90 * ( Math.PI / 180 );
	   //obj.scale.set(2.145,2,2.145,2.145);
	   //var basescale = 2.68125;
	   obj.scale.set( 5, 5, 5 );
	   obj.position.set(0,65,-550);
	 obj.castShadow = true;
	 obj.receiveShadow = true;
    }   
);	  

//Library Interior

 	var libint = new THREE.ImageUtils.loadTexture("tex/books.jpg")     
libint.wrapS	= THREE.RepeatWrapping;
	libint.wrapT	= THREE.RepeatWrapping;
	libint.repeat.x= 200
	libint.repeat.y= 3500
	libint.offset.y = -0.3;
var loader = new THREE.ObjectLoader();	
loader.load("models/libraryint.json", 
    function ( obj ) {
	obj.material.map = libint;
	//obj.material.emmissive = 0xcccccc;
	obj.material.shininess = 1.4;
	obj.material.shading = THREE.SmoothShading;
	obj.material.side = THREE.FrontSide;
       scene.add( obj );
	   obj.rotation.y = -90 * ( Math.PI / 180 );
	   obj.scale.set(5, 5, 5);
	   //var basescale = 2.68125;
	  // obj.scale.set( 1, 1, 1 );
	   obj.position.set(0,65,-550);
	 obj.castShadow = true;
	 obj.receiveShadow = true;
    }   
);	  

}
						}
}
function addlandscape(){
// objects
var grassbillboardtex = new THREE.ImageUtils.loadTexture( 'tex/grass.png' );
			/*	geometry = new THREE.PlaneGeometry( 0.4, 0.4, 1 );

				for ( var i = 0; i < 500; i ++ ) {

					material = new THREE.MeshBasicMaterial( { map: grassbillboardtex, transparent: true, specular: 0xffffff, shading: THREE.FlatShading, side: THREE.DoubleSide} );

					var mesh = new THREE.Mesh( geometry, material );
					mesh.position.x = Math.floor( Math.random() * 100 - 50 ) * 0.1;
					mesh.position.y = 35.2;
					mesh.position.z = Math.floor( Math.random() * 100 - 50 ) * 0.1;
					mesh.rotation.y = Math.floor( Math.random() * 360 - 1 ) * 1;
					scene.add( mesh );
var mesh = new THREE.Mesh( geometry, material );
					obj.position.x = Math.floor( Math.random() * 100 - 50 ) * 0.1;
					obj.position.y = 65;
					obj.position.z = Math.floor( Math.random() * 100 - 50 ) * 0.1;
					obj.rotation.y = Math.floor( Math.random() * 360 - 1 ) * 1;
					scene.add( obj );

				}
*/
grassspriteMaterial = new THREE.SpriteMaterial( { map: grassbillboardtex, blending:THREE.AdditiveBlending} );
var grassSprite = new THREE.Sprite( grassspriteMaterial );
					grassSprite.scale.set(0.4, 0.4,0.4);
						for ( var i = 0; i < 500; i ++ ) {

						


				//

					
					}
					
				
//Terrain Detail
	var rocktex = new THREE.ImageUtils.loadTexture("tex/bark2.jpg")     
rocktex.wrapS	= THREE.RepeatWrapping;
	rocktex.wrapT	= THREE.RepeatWrapping;
	rocktex.repeat.x= 4
	rocktex.repeat.y= 4
	/*
					var loader = new THREE.ObjectLoader();	
loader.load("models/detailedtree.json", 
    function ( obj ) {
	obj.material.map = rocktex;
	//obj.material.emmissive = 0xcccccc;
	obj.material.shininess = 0.4;
	obj.material.shading = THREE.SmoothShading;
       scene.add( obj );
	  obj.geometry.mergeVertices();
		obj.geometry.computeVertexNormals();
	   //obj.scale.set(2.145,2,2.145,2.145);
	   obj.scale.set( 0.3, 0.3, 0.3 );
	   obj.position.set(2,65,124);
	 obj.castShadow = true;
	 obj.receiveShadow = true;
    }   
);		
*/
for ( var i = 0; i < 50; i ++ ) {
					var loader = new THREE.ObjectLoader();	
loader.load("models/detailedtree.json", 
    function ( obj ) {
	obj.material.map = rocktex;
	//obj.material.emmissive = 0xcccccc;
	obj.material.shininess = 0.4;
	obj.material.shading = THREE.SmoothShading;
       
	  obj.geometry.mergeVertices();
		obj.geometry.computeVertexNormals();
	   //obj.scale.set(2.145,2,2.145,2.145);
	   //obj.scale.set( 0.3, 0.3, 0.3 );
	   obj.position.set(0,65,124);
obj.position.x = Math.floor( Math.random() * 40 - 40 ) * 1;
					obj.position.y = 65;
					obj.position.z = Math.floor( Math.random() * 144 - 104 ) * 1 +124;
					obj.rotation.y = Math.floor( Math.random() * 360 - 1 ) * 1;
					var objscale=Math.floor( Math.random() * 2 - 1 ) * 0.3;
					obj.scale.set(objscale);
					scene.add( obj );
	 obj.castShadow = true;
	 obj.receiveShadow = true;
    }   
);	
}		
				}
// SKY?

var path = "tex/sunnysky/";
                var format = '.jpg';
                var urls = [
                    path + 'px' + format, path + 'nx' + format,
                    path + 'py' + format, path + 'ny' + format,
                    path + 'pz' + format, path + 'nz' + format
                ];

                skyCubemap = THREE.ImageUtils.loadTextureCube( urls );

                var shader = THREE.ShaderLib["cube"];
                shader.uniforms["tCube"].value = skyCubemap;

                // We're inside the box, so make sure to render the backsides
                // It will typically be rendered first in the mainScene and without depth so anything else will be drawn in front
                var skyMaterial = new THREE.ShaderMaterial({
                    fragmentShader : shader.fragmentShader,
                    vertexShader   : shader.vertexShader,
                    uniforms       : shader.uniforms,
                    depthWrite     : false,
                    side           : THREE.BackSide
                });

                // The box dimension size doesn't matter that much when the mainCamera is in the centre.  Experiment with the values.
                skyboxMesh = new THREE.Mesh(new THREE.BoxGeometry(40000, 40000, 40000, 1, 1, 1), skyMaterial);
                //scene.add(skyboxMesh);
				//skyboxMesh.rotation.y = -  * ( Math.PI / 180 );
				


//SUN Position
	
var sunspriteMaterial = new THREE.SpriteMaterial( 
					{ 
						map: new THREE.ImageUtils.loadTexture( 'tex/glow.png' ), 
						//useScreenCoordinates: false, alignment: THREE.SpriteAlignment.center,
						color: 0xaaaa55, transparent: false, blending: THREE.AdditiveBlending
					});
					var sunsprite = new THREE.Sprite( sunspriteMaterial );
					sunsprite.scale.set(1000, 1000, 50.0);	
					sunsprite.position.set( -100, 4000, 6000 );
					scene.add(sunsprite);	
	
			

//Any puddles
//CITY DETAIL
 var puddlealpha = new THREE.ImageUtils.loadTexture( 'tex/puddletex.jpg' );
					var loader = new THREE.ObjectLoader();	
loader.load("models/puddle.json", 
    function ( obj ) {
	obj.material.alphaMap = puddlealpha;
	
	obj.material.emmissive = 0x111111;
obj.material.envMap= skyCubemap;
	obj.material.shading = THREE.SmoothShading;
	obj.material.opacity = 0.5;
	obj.material.transparent = true;
       scene.add( obj );
	   //obj.scale.set(2.145,2,2.145,2.145);
	   obj.scale.set( 1, 1, 1 );
	   obj.position.set(5,65.01,0);
	 obj.castShadow = true;
	 obj.receiveShadow = true;
    }   
);
function sea(){
				//SEA
var parameters = {
				width: 10000,
				height: 10000,
				widthSegments: 2500,
				heightSegments: 2500,
				depth: 1500,
				param: 4,
				filterparam: 1
			}	
			var waterNormals;
waterNormals = new THREE.ImageUtils.loadTexture( 'tex/waternormals.jpg' );
				waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping; 
				water = new THREE.Water( renderer, camera, scene, {
					textureWidth: 256, 
					textureHeight: 256,
					waterNormals: waterNormals,
					alpha: 	0.86,
					sunDirection: light.position.clone().normalize(),
					sunColor: 0xffffff,
					waterColor: 0x012420,
					distortionScale: 70.0,
				} );
				mirrorMesh = new THREE.Mesh(
					new THREE.PlaneGeometry( parameters.width * 1, parameters.height * 1 ),
					water.material
				);
				mirrorMesh.add( water );
				mirrorMesh.rotation.x = - Math.PI * 0.5;
				scene.add( mirrorMesh );
				mirrorMesh.position.set(0,25,0);
				
 	var seafloortex = new THREE.ImageUtils.loadTexture("tex/seafloor.jpg"); 
		seafloortex.wrapS = seafloortex.wrapT = THREE.RepeatWrapping; 
	seafloortex.repeat.set( 80, 80 );
 geometry = new THREE.PlaneGeometry( 2000, 2000, 50, 50 );
                geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
				seafloormaterial = new THREE.MeshBasicMaterial( { map: seafloortex} );
                mesh = new THREE.Mesh( geometry, seafloormaterial );
				//mesh = new THREE.Mesh( geometry, watermaterial );
                mesh.castShadow = false;
                mesh.receiveShadow = true;
                scene.add( mesh );
}
				
	
//Enemies
   material = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true} );
var ballShape2 = new CANNON.Sphere(1);
            var ballGeometry = new THREE.SphereGeometry(ballShape2.radius, 24, 24);
                    var enemyBody = new CANNON.Body({ mass: 5 });
                    enemyBody.addShape(ballShape2);
                    var enemyMesh = new THREE.Mesh( ballGeometry, material );
                    world.add(enemyBody);
					enemyBody.linearDamping = 0.99
					enemyBody.fixedRotation = true;
                    scene.add(enemyMesh);
                    enemyMesh.castShadow = false;
                    enemyMesh.receiveShadow = false;
                    balls.push(enemyBody);
					ballMeshes.push(enemyMesh);
					enemyBody.position.set(0,185,4000);
					
					enemyMesh.position.set(enemyBody.position);
				
				// Add linked boxes
			/*	
                var size = 0.5;
                var he = new CANNON.Vec3(size,size,size*0.1);
                var boxShape = new CANNON.Box(he);
                var mass = 0;
                var space = 0.1 * size;
                var N = 5, last;
                var boxGeometry = new THREE.BoxGeometry(he.x*2,he.y*2,he.z*2);
                for(var i=0; i<N; i++){
                    var boxbody = new CANNON.Body({ mass: mass });
                    boxbody.addShape(boxShape);
                    var boxMesh = new THREE.Mesh(boxGeometry, material);
                    boxbody.position.set(5,(N-i)*(size*2+2*space) + size*2+space,0);
                    boxbody.linearDamping = 0.01;
                    boxbody.angularDamping = 0.01;
                    // boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    world.add(boxbody);
                    scene.add(boxMesh);
                    boxes.push(boxbody);
                    boxMeshes.push(boxMesh);


                    if(i!=0){
                        // Connect this body to the last one
                        var c1 = new CANNON.PointToPointConstraint(boxbody,new CANNON.Vec3(-size,size+space,0),last,new CANNON.Vec3(-size,-size-space,0));
                        var c2 = new CANNON.PointToPointConstraint(boxbody,new CANNON.Vec3(size,size+space,0),last,new CANNON.Vec3(size,-size-space,0));
                        world.addConstraint(c1);
                        world.addConstraint(c2);
                    } else {
                        mass=0.3;
                    }
                    last = boxbody;
                }
				*/
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }

            var dt = 1/60;
            function animate() {
			stats.begin();
			stats.end();
                requestAnimationFrame( animate );
				
                if(controls.enabled){
                    world.step(dt);

                    // Update ball positions
                    for(var i=0; i<balls.length; i++){
                        ballMeshes[i].position.copy(balls[i].position);
                        ballMeshes[i].quaternion.copy(balls[i].quaternion);
                    }	
					
                    // Update box positions
                    for(var i=0; i<boxes.length; i++){
                        boxMeshes[i].position.copy(boxes[i].position);
                        boxMeshes[i].quaternion.copy(boxes[i].quaternion);
                    }
	
                }
				controls.enabled==false;
                controls.update( Date.now() - time );
				//water.material.uniforms.time.value += 0.8 / 60.0;
				//water.render();
				//sunSphere.update(sunAngle)
				//Correct player position if underwater
					if (sphereBody.position.y < 26){
				sphereBody.position.y=26;
				}	
                renderer.render( scene, camera );			
                time = Date.now();
            }

            var ballShape = new CANNON.Sphere(0.1);
            var ballGeometry = new THREE.SphereGeometry(ballShape.radius/2, 24, 24);
            var shootDirection = new THREE.Vector3();
            var shootVelo = 100;
            var projector = new THREE.Projector();
            function getShootDir(targetVec){
                var vector = targetVec;
                targetVec.set(0,0,1);
                projector.unprojectVector(vector, camera);
                var ray = new THREE.Ray(sphereBody.position, vector.sub(sphereBody.position).normalize() );
                targetVec.x = ray.direction.x;
                targetVec.y = ray.direction.y;
                targetVec.z = ray.direction.z;
            }
            window.addEventListener("click",function(e){
                if(controls.enabled==true){
				if(canshoot=true){
				console.log(sphereBody.position);
                    var x = sphereBody.position.x;
                    var y = sphereBody.position.y;
                    var z = sphereBody.position.z;
                    var ballBody = new CANNON.Body({ mass: 0.00001 });
					ballBody.linearDamping = 0;
                    ballBody.addShape(ballShape);
                    var ballMesh = new THREE.Mesh( ballGeometry, spellmaterial );
					var balllight = new THREE.PointLight(0xFF9500, 1, 10 );
					ballMesh.add(balllight);
					balllight.position.set(0,0,1);
                    world.add(ballBody);
                    scene.add(ballMesh);
                    ballMesh.castShadow = false;
                    ballMesh.receiveShadow = false;
                    balls.push(ballBody);
					
					var spriteMaterial = new THREE.SpriteMaterial( 
					{ 
						map: new THREE.ImageUtils.loadTexture( 'tex/glowspell.png' ), 
						//useScreenCoordinates: false, alignment: THREE.SpriteAlignment.center,
						color: 0xcc0000, transparent: false, blending: THREE.AdditiveBlending
					});
					var sprite = new THREE.Sprite( spriteMaterial );
					sprite.scale.set(1, 1, 2.0);
					ballMesh.add(sprite); // this centers the glow at the mesh
                    ballMeshes.push(ballMesh);
                    getShootDir(shootDirection);
                    ballBody.velocity.set(  shootDirection.x * shootVelo,
                                            shootDirection.y * shootVelo,
                                            shootDirection.z * shootVelo);
				ballBody.addEventListener("collide",function(e){
              console.log("Spell impact");
             console.log("Collided with:",e.body);
			 scene.remove(ballMesh);
			 world.remove(ballBody);	 
          });	
		  

                    // Move the ball outside the player sphere
                    x += shootDirection.x * (sphereShape.radius*1.02 + ballShape.radius);
                    y += shootDirection.y * (sphereShape.radius*1.02 + ballShape.radius);
                    z += shootDirection.z * (sphereShape.radius*1.02 + ballShape.radius);
                    ballBody.position.set(x,y,z);
                    ballMesh.position.set(x,y,z);
					}
                }
            });

        </script>
    </body>
</html>
